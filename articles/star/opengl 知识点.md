---
tag: 'star'
date: '2024/3/13'
---

简答题、选择题、填空题

### 图形学概论

1. 什么是图形学。图形学是计算机科学的一个分支，它研究如何创建和操纵视觉内容，特别是3D视觉。它包括渲染，动画，视频处理，图像处理，计算几何和图像识别等领域。
   - 游戏开发：图形学是现代电子游戏中不可或缺的一部分，用于创建游戏的视觉效果。
   - 电影和电视：图形学用于创建电影和电视中的特效和动画。
   - 虚拟现实和增强现实：图形学用于创建虚拟现实和增强现实的视觉效果。
   - 计算机辅助设计（CAD）：图形学用于创建和修改设计图。
   - 医学成像：图形学用于创建和分析医学图像，如MRI和CT扫描。
   - 地理信息系统（GIS）：图形学用于创建和分析地理数据的视觉表示。

2. 哪个不属于图形标准
   - ODBC 开放数据库连接
   - OpenGL，PHIGS，GKS 都是图形学标准

3. 图形构成元素分为
   - 线(几何) 要素，刻画轮廓形状
   - 面(非几何) 要素，刻画颜色材质

4. OpenGL 六种坐标系
   - 物体坐标系：物体的本地坐标系，物体的顶点坐标是相对于物体中心的。
   - 世界坐标系：全局坐标系，所有的物体都在这个坐标系中定位。
   - 视图坐标系：相对于摄像机的坐标系，摄像机位于原点，朝向-z轴。
   - 裁剪坐标系：所有在摄像机视野内的物体都在一个立方体内（-w <= x, y, z <= w）。
   - 归一化设备坐标系：所有在摄像机视野内的物体都在一个立方体内（-1 <= x, y, z <= 1）。
   - 屏幕坐标系：最终的2D屏幕坐标系，所有的物体都被映射到这个2D平面上。

5. 已知分辨率 1024 * 1024 的显示模式，每个像素 24 位颜色，至少需要帧缓存？
   - 1字节 = 8位，因此 帧缓存 = 1024 * 1024 * 3 = 3MB

6. 如果某图形系统分辨率 1024 * 768，颜色为 24 位，至少需要帧缓存？
   - 约为 2.25MB

7. 在数值微分算法 DDA 算法，哪些是正确的
   - 采用直线的两点式方程：对，这样来计算点
   - 引入了增量思想：对，增量逐步计算
   - 采用了直线斜截式方程：对，也可以基于这个方程计算
   - DDA 算法效率提高到整数的加法：DDA 算法涉及浮点数计算，因此效率不如 bresenham

8. 简述中点Bresenham算法生成直线的基本流程
   - 初始化两个端点，确定起点为较低的点。
   - 计算两个可能的像素位置的中点。
   - 如果中点在直线上方，则选择下一个像素为下方的像素，否则选择上方的像素。
   - 重复上述步骤，直到到达终点。

9. 简述改进的Bresenham算法生成直线的基本流程
   - 初始化两个端点，确定起点为较低的点。
   - 计算两个可能的像素位置的中点。
   - 如果中点在直线上方，则选择下一个像素为下方的像素，否则选择上方的像素。在这个过程中，使用整数运算替代浮点运算，提高了效率。
   - 重复上述步骤，直到到达终点。

10. OpenGL中，指定二维世界坐标系 glOrtho2D 函数、画点函数glVertex*()、画线函数 GL_LINES --- glBegin，glEnd 函数对参数选择
   - glOrtho2D()：设置二维正交投影，参数是左、右、下、上四个边界的值。
   - 画点函数：使用 glBegin(GL_POINTS) 和 glEnd() 函数来画点，glVertex*() 函数用于指定点的位置。
   - glVertex*() 函数：指定顶点的位置，有多个版本，可以接受2D、3D或4D的顶点坐标。
   - 画线函数 GL_LINES：使用 glBegin(GL_LINES) 和 glEnd() 函数来画线，glVertex*() 函数用于指定线的端点。

11. 什么库是 OpenGL 的核心库，函数都以什么为前缀。什么是 OpenGL 的应用工具包，具有包含输入和显示窗口的函数，实现程序结果和人机交互
   - OpenGL的核心库是GL库，所有的OpenGL函数都以"gl"为前缀
   - OpenGL的应用工具包是GLUT（OpenGL Utility Toolkit），它包含了一些用于处理输入和显示窗口的函数，可以帮助实现程序的结果显示和人机交互。

12. 图像的定义和输入输出都是在一定坐标系下进行，这些坐标系为：
    - 建模坐标系
    - 世界坐标系
    - 观察(视图) 坐标系 & 投影坐标系
    - 规范化设备坐标系
    - 屏幕坐标系

1.  下列坐标变换中会产生前后维度变化的是？
    - 建模变换：平移旋转和缩放物体
    - 观察变换：世界坐标系转换成视图坐标系，不会转变维度
    - 投影变换：3D 视图坐标系投影成 2D 的过程，会产生前后维度变换
    - 视口变换：投影坐标系转换成屏幕坐标系

2.  简述观察流水线的运行步骤
    - 建模变换：在物体坐标系中进行平移、旋转和缩放等操作，将物体放置到世界坐标系中的适当位置。
    - 观察变换：将世界坐标系转换为视图坐标系，也就是将摄像机放置在原点，朝向-z轴。
    - 投影变换：将3D视图坐标系投影到2D投影坐标系，这个过程会产生前后维度的变化。
    - 视口变换：将投影坐标系转换为屏幕坐标系，也就是将图形映射到屏幕的特定区域。

3.  简述下列代码运行结果
    答：绘制了绿色三角形
    ```cpp
    void display() {
        glClear(GL_COLOR_BUFFER_BIT);
        glColor3f(0.0, 1.0, 0.0); // 绿色
        glBegin(GL_POLYGON);
            glVertex2f(-0.7, -0.7); // 三个顶点组成了三角形
            glVertex2f(0.7, -0.7);
            glVertex2f(0, 0.7);
        glEnd();
        glFlush();
    }
    ```

4.  模型变换是从建模坐标系变换到什么坐标系中？
    - 建模坐标系 -> 世界坐标系`

5.  圆的扫描转换
    - 八分画圆法：计算出 1/8 个圆然后利用对称性完成  
      - 首先，确定圆心和半径
      - 然后，计算出 1/8 圆的点，可以通过第一象限内从 x 轴开始向 y 轴逐点扫描实现
      - 最后，映射到其他 7/8 个圆上
    - 中点 bresenham 画圆法：通过整数代替浮点数，也利用了对称性
      - 首先，确定圆心和半径
      - 然后，初始化决策参数，选择起始点
      - 每一步，根据决策参数选择下一个点，更新决策参数
      - 重复上述，直到画完 1/8 圆
      - 最后，映射到其他 7/8 个圆上

6.  椭圆的扫描转换
    - 在 Bresenham 画圆中，决策参数的计算取决于当前点到圆的距离，如果小于 0.5 则下一个点是东点，否则是东北点
    - 在 Bresenham 画椭圆中，取决于两个轴的长度，分成 2 个区域确定是东还是北

7.  采用 X-扫描线算法 对多边形进行填充，写出新边、有效边表每个节点的存储结构，并分析 X-扫描线算法的步骤和处理扫描线的步骤

X-扫描线算法是一种常用的多边形填充算法，它的基本思想是从多边形的最低点开始，沿y轴正方向逐行扫描，直到达到多边形的最高点

新边表 ET 和有效边表 AET 是X-扫描线算法的关键数据结构：
- y上：多边形的最高y坐标
- y下：多边形的最低y坐标
- x：与当前扫描线相交的x坐标
- 斜率倒数：边的斜率的倒数

X-扫描线算法的步骤如下:
1. 初始化 ET 和 AET（Edge Table, Active Edge Table）
2. 对于每一条扫描线（从最低点到最高点）
   - 将 ET 中当前扫描线的所有边添加到 AET
   - 删除 AET 中已经处理过的边
   - 按 x 坐标对 AET 进行排序
   - 填充 AET 中的边对之间的像素
   - 更新 AET 中每条边的 x 坐标

20. 多边形填充算法中，错误的是？
   - 扫描线算法对像素只访问一次，主要缺点是对表的维持和排序耗费较大
   - 边填充算法基本思想是对每一条线和多边形的交点，右方像素取补
   - 边填充算法适合帧缓冲存储器的图形系统
   - 边标志算法不能解决像素被重复访问的缺点，这是错误的，主要优点就是可以解决像素被重复访问的问题，通过在像素处设置一个标志来避免重复访问

21. 多边形绘制
   - 区域的几种表示方式：
     - 位图表示：每个像素对应一个位，如果像素在区域内为 1 否则为 0
     - 边界表示：存储区域的边界信息，如边的起点终点，边的方向
     - 运行编码：对连续的像素进行编码，每个编码包含像素的位置和长度
     - 二维数组：每个元素对应一个像素，如果像素在区域内，则为 1 否则为 0

22. Y 向连贯性算法
    - Y 连贯性算法，也称为扫描线填充算法，是一种多边形填充算法。它从多边形的最低点开始，沿y轴正方向逐行扫描，直到达到多边形的最高点。在每一行中，算法找出所有与当前扫描线相交的边，然后根据这些交点填充像素

23. 多边形填充基础算法
    - 边缘填充算法：基本思想是对每一条线和多边形的交点，右方像素取补；
    - 栅栏填充算法：也就是 X 扫描线算法
    - 边标志算法：可以解决像素被重复访问的问题，可以处理复杂的多边形但是可能导致填充的不连续性

24. 图元属性更改函数
    - 颜色 glColor3f(1.0, 1.0, 1.0)
    - 线型 glLineWidth(2.0)
    - 填充 glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) // 改为线框模式

25. 走样和反走样 Anti-aliasing
    - 走样：是由于采样频率低于信号频率的视觉失真效果；如果没有足够的分辨率来精确显示图形，就会出现走样；具体形式是锯齿
    - 反走样：抗锯齿，取灰度或者之类的

26. 过取样和区域取样
    - 过取样：在每个像素中采样多个点，然后计算平均颜色作为像素的颜色和方法
    - 区域取样：是一种考虑像素覆盖的整个区域，而不仅仅是像素中心的颜色的方法

27. 计算机显示设备一般使用的颜色模型
    - RGB 模型、RGBA 模型
    - CYMK 模型
    - HSV 模型
    - HSL 模型

28. 颜色一般用 RGB 三原色含量来表示，对于不具有彩色功能的显示系统，颜色显示为：
    - 灰度级 或者 亮度级

29. 直线的属性包括线宽、颜色和？
    - 线型

30. 什么是颜色调和，设为 glBlendFunc(GL_ZERO, GL_ONE)
    - 颜色调和操作将要绘制的像素颜色 与 当前颜色缓冲器里的颜色做比较，根据所选混合函数以及将要绘制的对象颜色 与 当前缓冲器中的颜色相混合产生一种颜色
    - 如果设置了 glBlenderFunc(GL_ZERO, GL_ONE) 则表示完全不使用源颜色

31. 颜色函数
    - glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB)

32. 点线的属性函数
    - glPolygonMode(face, displayMode)
    - glLineStipple(repeatFactor, pattern)
    - glShadeModel(GL_SMOOTH)

33. 简述二位观察流水线
- 对象描述：这是流水线的开始，我们需要提供一个或多个二维对象的描述。这通常包括对象的形状、位置、颜色等属性。
- 几何变换：在这一步，我们会对对象进行各种几何变换，如平移、旋转和缩放。这些变换可以改变对象的位置、方向和大小。
- 裁剪：裁剪是去除那些不会出现在最终图像中的部分。这通常包括那些完全在视窗之外的对象，以及那些-只有一部分在视窗内的对象的视窗之外的部分。
- 光栅化：光栅化是将描述对象的向量数据转换为像素数据的过程。这一步通常包括扫描转换、着色和抗走样等操作。
- 显示：最后，生成的像素数据被发送到显示设备（如计算机屏幕），并在那里显示出来。

34. 简述一下 Cohen-Sutherland 算法的主要思想
- 对线段的两个端点进行编码
- 如果两个端点的编码都为 0，那么线段完全在窗口内，不需要裁剪
- 如果两个端点的编码的逻辑与运算的结果不为 0，那么线段完全在窗口外，可以直接被丢弃
- 否则，线段与窗口有交集，需要进行裁剪。选择一个在窗口外的端点，然后根据它的编码，找到线段与窗口边界的交点，用交点替换这个端点，然后重复上述步骤

35. 简述一下中点分割算法的主要思想
- 首先，检查线段是否可以被完全接受或完全拒绝。如果线段完全在裁剪窗口内，那么它可以被完全接受；如果线段完全在裁剪窗口外，那么它可以被完全拒绝
- 如果线段既不可以被完全接受，也不可以被完全拒绝，那么找到线段的中点，然后将线段分割为两部分
- 对分割后的两部分线段重复上述步骤，直到所有的线段都可以被完全接受或完全拒绝

36. 简述一下 Liang-Barsky 算法的主要思想
- 首先，将线段参数化为P = P0 + t(P1 - P0)，其中P0和P1是线段的两个端点，t是参数，范围在0到1之间
- 然后，对于裁剪窗口的每一个边界，计算对应的t值。例如，对于左边界，t的值是(Xmin - X0) / (X1 - X0)，其中Xmin是裁剪窗口左边界的x坐标，X0和X1是线段端点的x坐标
- 对于每一个计算出的t值，如果它对应的边界是线段的左边或下边，那么它将可能增大t的最小值；如果它对应的边界是线段的右边或上边，那么它将可能减小t的最大值
- 最后，如果t的最小值小于最大值，那么线段与裁剪窗口的交点就是对应于t最小值和最大值的点

37. Cohen-Sutherland 屏幕分辨率 1024 * 1024，最多被分割几次？
- 2 * log2(1024) = 20

38. 三维观察
- gluLookAt(3f, 3ref, 3V)
- gluPerspective(theta, aspect, dnear, dfar)
- gluFrustum(xwmin, xwman, ywmin, ywmax, dnear, dfar)


39. 明暗处理
    - glLight(lightName, lightProp, propValue)
    - glEnable(lightName)
    - glEnable(GL_LIGHTING)
    - glLightfv()
    - glMaterial(surface, sufProp, propValue)

40. 在纹理映射中，建立物体空间表面和纹理空间之间的对应关系，主要包含哪两方面工作
    - 纹理坐标生成：这是指为物体的每个顶点分配一个纹理坐标。纹理坐标通常是二维的，范围在0到1之间，表示纹理图像上的位置。纹理坐标可以在模型创建时手动指定，也可以通过程序自动生成
    - 纹理采样：这是指根据纹理坐标从纹理图像中取样颜色。由于纹理坐标通常是浮点数，而纹理图像是由像素组成的，所以需要使用一种插值方法（如最近邻插值或双线性插值）来计算纹理颜色

41. Phong 模型
    - Ambient，Diffuse，Specular

42. 矩阵变换
```cpp
// 平移 y
1 0 0
0 1 0
y y 1
```

```cpp
// 旋转 thrta
cos  sin 0
-sin cos 0
0    0   1
```

```cpp
// 缩放
x 0 0
0 y 0
0 0 1
```
