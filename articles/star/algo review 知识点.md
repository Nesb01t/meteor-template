---
tag: 'star'
date: '2024/3/10'
---

### 问题思路

- N 皇后问题
  然而 N 皇后问题是全局优化问题，需要找到所有皇后的放置位置，要求他们不在同一行列对角线上，因此每一步的最优解不能保证最终得到全局最优解；可能需要回溯改变之前的选择

- 背包问题
  分数背包（按照价值/重量排序）可以，但 0-1 背包就不行了，0-1 背包只能选择取或者不取，不能取物品的一部分，通常使用动态规划解决

- 最小花费生成树问题 (!Prim/Kruskal)
  我们的目标是找到一个图的所有顶点的子集，使得子集中所有边的权重之和最小，而且这个子集构成一棵树；贪心算法可以每一步选择可用的边中权重最小的，而且链接的两个顶点在已经选择的树中不构成环，被称为 Prim 算法或者 Kruskal 算法

- 单源最短路径问题 (!Dijkstra)
  这是贪心的一种特殊形式 Dijkstra 算法；他从源顶点开始初始化所有顶点的最短路径长度，然后选择当前没访问过且具有最短路径长度的顶点，更新该顶点的所有邻居路径长度，直到所有顶点都被访问过

- 旅行商问题
  NP 问题

### 性质 of 贪心法

贪心是一种每一步选择都采取当下最优选，而希望最终全局最优的算法

1. 贪心选择性质 Greedy Choice Property
   局部最优选择能导致全局最优选择

2. 最优子结构 Optimal Substructure
   一个问题的最优解包含子问题的最优解，也就是说通过合并子问题的解可以得到原问题的解

### 性质 of 动态规划

1. 重叠子问题 Overlapping Subproblems
   一个问题可以被分解成子问题，可以有很多重复的部分，我们利用这个性质，通过存储已解决的子问题的解来避免重复计算，也就是记忆化
2. 最优子结构 Optimal Substructure (和贪心一样)

### 性质 of 分治法

这是很多高效算法的基础

1. 分解 Divide 分解成一系列子问题
2. 解决 Conquer 递归地解决小问题
3. 合并 Combine 合并成原问题

### 常见编程技术

1. 预排序 Pre-ordering 树遍历策略，在预排序遍历中先访问根节点，然后递归地遍历左树，再遍历右数

2. 递归 Recursive Call 同其名称

### 排序

1. 快速排序 Quick Sort
   每次选一个节点来划分 2 部分

   - 时间复杂度 nlogn 最好和平均，每次均匀分成 2 份因此深度 logn，每层操作 n 因此 nlogn
   - 最坏 n^2 如果每次一部分 n-1 元素，另一部分 0 个元素就 n^2 了
   - 空间复杂度 logn 因为他是一种递归算法，最坏情况会达到 n

2. 冒泡排序 Bubble Sort
   顺序一直往上冒泡

   - 最好情况下已经排好的只需要 n，最坏情况 n^2
   - 空间复杂度 1 因为他是原地排序的，不需要额外空间

3. 选择排序 Selection Sort
   每一次找到最大的放到前面

   - 最好最坏平均都是 n^2
   - 空间复杂度 1 也是原地的

4. 堆排序 Heap Sort
   一种树形选择排序，对选择排序的优化，堆顶元素必为最小项（第一个元素）
5. 归并排序 Merge Sort
   用的分治法 Divide and Conquer，将每个子序列有序，然后将两个有序表合成一个有序表，称为二路归并

6. 插入排序 Insertion Sort
   对于未排序数据，在已排序数据中从后往前扫描并插入
7. 希尔排序 Shell Sort
   插入排序的增强版，缩小增量排序，针对插入排序的特点：插入排序对已基本有序的算法效率高，但一般来说是低效的，因为每次只能将数据移一位
8. 计数排序 Counting Sort
   稳定的线性时间排序算法，使用额外的数组 C，其中第 i 个元素是待排序数组 A 里面值等于 i 的元素的个数，然后根据 C 将 A 的元素排到正确的位置
9. 桶排序 Bucket Sort
   假设输入数据服从均匀分布，先把数据分到有限的桶里然后再分别排序
10. 基数排序 Radix Sort
    一种非比较整数排序算法，按照位数切割成不同数字，然后按每个位数来比较
